% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getClusteredPCs.R
\name{getClusteredPCs}
\alias{getClusteredPCs}
\title{Use clusters to choose the number of PCs}
\usage{
getClusteredPCs(pcs, FUN = NULL, ..., min.rank = 5,
  max.rank = ncol(pcs), by = 1)
}
\arguments{
\item{pcs}{A numeric matrix of PCs, where rows are cells and columns are dimensions representing successive PCs.}

\item{FUN}{A clustering function that takes a numeric matrix with rows as cells and
returns a vector containing a cluster label for each cell.}

\item{...}{Further arguments to pass to \code{FUN}.}

\item{min.rank}{Integer scalar specifying the minimum number of PCs to use.}

\item{max.rank}{Integer scalar specifying the maximum number of PCs to use.}

\item{by}{Integer scalar specifying what intervals should be tested between \code{min.rank} and \code{max.rank}.}
}
\value{
A \linkS4class{DataFrame} with one row per tested number of PCs.
This contains the fields:
\describe{
\item{\code{n.pcs}:}{Integer scalar specifying the number of PCs used.}
\item{\code{n.clusters}:}{Integer scalar specifying the number of clusters identified.}
\item{\code{clusters}:}{A \linkS4class{List} containing the cluster identities for this number of PCs.}
}
The metadata of the DataFrame contains \code{chosen}, 
an integer scalar specifying the \dQuote{ideal} number of PCs to use.
}
\description{
Cluster cells after using varying number of PCs,
and pick the number of PCs using a heuristic based on the number of clusters.
}
\details{
Any \code{FUN} can be used that automatically chooses the number of clusters based on the data.
The default is a graph-based clustering method using \code{\link{buildSNNGraph}} and \code{\link{cluster_walktrap}},
where arguments in \code{...} are passed to the former.
Users should not supply \code{FUN} where the number of clusters is fixed in advance, 
(e.g., k-means, hierarchical clustering with known \code{k} in \code{\link{cutree}}).

The idea is that more PCs should include more biological signal, allowing \code{FUN} to detect more distinct clusters.
However, this only holds up to the point that the extra signal outweights the added noise at high dimensions.
With too many PCs, we would expect to see a decrease in the number of clusters 
as it becomes more difficult for \code{FUN} to distinguish between them.
The \dQuote{ideal} number of PCs can thus be chosen at the maximum number of clusters.

We add another constraint that the number of clusters must be no greater than the number of PCs minus 1.
This is because we need at least \code{d} PCs to guarantee that \code{d+1} subpopulations are separated.
(For example, in the most extreme case, each subpopulation could be defined by a unique set of marker genes driving its own PC.)
The aim is to avoid situations where \code{FUN} generates many clusters at low rank due to the near-absence of noise.
This would retain very few PCs and may discard more subtle biological factors.

The identities of the output clusters are returned at each step for use in packages like \pkg{clustree}.
}
\examples{
sce <- scater::mockSCE()
sce <- scater::logNormCounts(sce)
sce <- scater::runPCA(sce)

output <- getClusteredPCs(reducedDim(sce))
output

metadata(output)$chosen

}
\seealso{
\code{\link{runPCA}}, to compute the PCs in the first place.

\code{\link{buildSNNGraph}}, for arguments to use in with default \code{FUN}.
}
\author{
Aaron Lun
}
